```ts
type Optional<T, K extends keyof T> = Partial<Pick<T, K>> & Omit<T, K>;
export type SizeKeys = "w" | "h";
export type AutomaticallySizedLayoutOptions = Omit<LayoutOptions, SizeKeys>;
export type SquareSizeLayoutOptions = AutomaticallySizedLayoutOptions;
export type PartialSizeLayoutOptions = Optional<LayoutOptions, SizeKeys>;
export type SelectableStaticContainerLayoutOptions = AutomaticallySizedLayoutOptions | PartialSizeLayoutOptions;
export type AnyStaticContainer = AbstractStaticContainer<SelectableStaticContainerLayoutOptions>;
export abstract class AbstractStaticContainer<T extends SelectableStaticContainerLayoutOptions> extends ExtensionBase(Component) {
    protected children: Array<Components> = new Array();
    private wasInitialized: boolean = false;
    private afterInitializedOperationQueue: Set<() => void> = new Set();
    protected override animationZoomShouldSlidePosition: boolean = false;
    constructor(protected readonly layoutOptions: MaybePointerLike<T>) {
        super();
        this.once("onInitialized", () => {
            this.wasInitialized = true;
            this.afterInitializedOperationQueue.forEach(op => op());
            this.afterInitializedOperationQueue.clear();
            this.afterInitializedOperationQueue = null;
        });
    }
    override getCacheKey(lc: LayoutContext): string {
        const { CACHE_KEY_DELIMITER } = Component;
        return super.getCacheKey(lc) +
            CACHE_KEY_DELIMITER +
            Object.values(Component.computePointerLike(this.layoutOptions)).join(CACHE_KEY_DELIMITER) +
            CACHE_KEY_DELIMITER +
            Array.from(this.children).map(c => c.getCacheKey(lc)).join(CACHE_KEY_DELIMITER);
    }
    override invalidateLayoutCache(): void {
        this.layoutCache.invalidate();
        this.children.forEach(child => child.invalidateLayoutCache());
    }
    override destroy(): void {
        this.children.forEach(child => {
            child.destroy();
            this.context.removeChildComponent(child);
        });
        this.children = null;
        super.destroy();
    }
    override setVisible(...args: SetVisibleOverloadParameters[0]): void;
    override setVisible(...args: SetVisibleOverloadParameters[1]): void;
    override setVisible(...args: SetVisibleOverloadParameters[2]): void;
    override setVisible(...args: SetVisibleOverloadParameters[3]): void;
    override setVisible(...args: SetVisibleOverloadParameters[4]): void;
    override setVisible(
        ...[toggle]: SetVisibleImplementationParameters
    ): void {
        (super.setVisible as (...args: ReadonlyArray<any>) => {})(...arguments);
        this.children.forEach(child => {
            child.setVisible(toggle, false);
        });
    }
    public addChildren(...children: Array<Components>): this {
        children.forEach(child => this.addChild(child));
        return this;
    }
    public getChildren(): Array<Components> {
        return this.children.slice();
    }
    public sortChildren(compareFn?: (a: Components, b: Components) => number): void {
        this.children.sort(compareFn);
    }
    public addChild(child: Components): this {
        this.children.push(child);
        const addChildComponentOperation = () => { this.context.addChildComponent(child); };
        if (this.wasInitialized) {
            addChildComponentOperation();
        } else {
            this.afterInitializedOperationQueue.add(addChildComponentOperation);
        }
        return this;
    }
    public removeChild(child: Components): this {
        const index = this.children.indexOf(child);
        if (index > -1) {
            this.children.splice(index, 1);
        }
        const removeChildComponentOperation = () => { this.context.removeChildComponent(child); };
        if (this.wasInitialized) {
            removeChildComponentOperation();
        } else {
            this.afterInitializedOperationQueue.add(removeChildComponentOperation);
        }
        return this;
    }
    public hasChild(child: Components): boolean {
        return this.children.includes(child);
    }
}
export class StaticHContainer extends AbstractStaticContainer<AutomaticallySizedLayoutOptions> {
    public override[OBSTRUCTION_AFFECTABLE]: boolean = false;
    constructor(
        layoutOptions: MaybePointerLike<AutomaticallySizedLayoutOptions>,
        private readonly reverseChildrenRender: MaybePointerLike<boolean> = false,
        private readonly childReplaceOffset: MaybePointerLike<number | null> = null,
    ) {
        super(layoutOptions);
    }
    override layout(lc: LayoutContext): LayoutResult {
        const { ctx, containerWidth, containerHeight } = lc;
        let totalWidth = 0;
        let maxHeight = 0;
        if (this.children.length > 0) {
            this.children.forEach(child => {
                const { w: childW, h: childH } = child.layout(
                    {
                        ctx,
                        containerWidth,
                        containerHeight,
                        originX: 0,
                        originY: 0,
                    },
                );
                totalWidth += childW;
                maxHeight = Math.max(maxHeight, childH);
            });
        }
        return Layout.layout(
            {
                ...Component.computePointerLike(this.layoutOptions),
                w: totalWidth,
                h: maxHeight,
            },
            lc,
        );
    }
    override render(ctx: CanvasRenderingContext2D): void {
        if (!this.isRenderable) return;
        super.render(ctx);
        this.update(ctx);
        if (this.children.length > 0) {
            const computedReverseChildrenRender = Component.computePointerLike(this.reverseChildrenRender);
            const computedChildReplaceOffset = Component.computePointerLike(this.childReplaceOffset);
            let currentX = 0;
            if (computedReverseChildrenRender) {
                this.children.forEach(child => {
                    const childLayout = child.cachedLayout({
                        ctx,
                        containerWidth: this.w,
                        containerHeight: this.h,
                        originX: this.x + currentX,
                        originY: this.y,
                    });
                    currentX += (computedChildReplaceOffset ?? childLayout.w);
                });
            }
            this.children.forEach(child => {
                const childLayout = child.cachedLayout({
                    ctx,
                    containerWidth: this.w,
                    containerHeight: this.h,
                    originX: this.x + currentX,
                    originY: this.y,
                });
                child.setX(childLayout.x);
                child.setY(childLayout.y);
                child.setW(childLayout.w);
                child.setH(childLayout.h);
                currentX +=
                    (computedReverseChildrenRender ? -1 : 1) *
                    (computedChildReplaceOffset ?? childLayout.w);
                renderPossibleComponent(ctx, child);
            });
        }
    }
}
export class StaticVContainer extends AbstractStaticContainer<AutomaticallySizedLayoutOptions> {
    public override[OBSTRUCTION_AFFECTABLE]: boolean = false;
    constructor(
        layoutOptions: MaybePointerLike<AutomaticallySizedLayoutOptions>,
        private readonly reverseChildrenRender: MaybePointerLike<boolean> = false,
        private readonly childReplaceOffset: MaybePointerLike<number | null> = null,
    ) {
        super(layoutOptions);
    }
    override layout(lc: LayoutContext): LayoutResult {
        const { ctx, containerWidth, containerHeight } = lc;
        let totalHeight = 0;
        let maxWidth = 0;
        if (this.children.length > 0) {
            this.children.forEach(child => {
                const { w: childW, h: childH } = child.layout(
                    {
                        ctx,
                        containerWidth,
                        containerHeight,
                        originX: 0,
                        originY: 0,
                    },
                );
                totalHeight += childH;
                maxWidth = Math.max(maxWidth, childW);
            });
        }
        return Layout.layout(
            {
                ...Component.computePointerLike(this.layoutOptions),
                w: maxWidth,
                h: totalHeight,
            },
            lc,
        );
    }
    override render(ctx: CanvasRenderingContext2D): void {
        if (!this.isRenderable) return;
        super.render(ctx);
        this.update(ctx);
        if (this.children.length > 0) {
            const computedReverseChildrenRender = Component.computePointerLike(this.reverseChildrenRender);
            const computedChildReplaceOffset = Component.computePointerLike(this.childReplaceOffset);
            let currentY = 0;
            if (computedReverseChildrenRender) {
                this.children.forEach(child => {
                    const childLayout = child.cachedLayout({
                        ctx,
                        containerWidth: this.w,
                        containerHeight: this.h,
                        originX: this.x,
                        originY: this.y + currentY,
                    });
                    currentY += (computedChildReplaceOffset ?? childLayout.h);
                });
            }
            this.children.forEach(child => {
                const childLayout = child.cachedLayout({
                    ctx,
                    containerWidth: this.w,
                    containerHeight: this.h,
                    originX: this.x,
                    originY: this.y + currentY,
                });
                child.setX(childLayout.x);
                child.setY(childLayout.y);
                child.setW(childLayout.w);
                child.setH(childLayout.h);
                currentY +=
                    (computedReverseChildrenRender ? -1 : 1) *
                    (computedChildReplaceOffset ?? childLayout.h);
                renderPossibleComponent(ctx, child);
            });
        }
    }
}
```
このコードのStaticHContainer/StaticVContainerで、childが一個でも消されると大幅に一瞬で他のコンポーネントの位置が変わってしまいます。滑らかに位置を補完するには？